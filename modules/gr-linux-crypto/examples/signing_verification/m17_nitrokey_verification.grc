options:
  parameters:
    author: gr-linux-crypto
    catch_exceptions: 'True'
    category: '[gr-linux-crypto]/Examples'
    cmake_opt: ''
    comment: ''
    copyright: Copyright 2024
    description: M17 voice signature verification using gr-nacl Ed25519. Verifies
      signatures embedded in M17 Codec2 frames after demodulation.
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: m17_nitrokey_verification
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: M17 Verification with Nitrokey
    window_size: (1400, 900)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 0.0]
    rotation: 0
    state: enabled

blocks:
- name: authenticate_button
  id: variable_qtgui_push_button
  parameters:
    comment: ''
    gui_hint: ''
    label: Authenticate Nitrokey
    pressed: '1'
    released: '0'
    type: int
    value: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 16.0]
    rotation: 0
    state: enabled
- name: nitrokey_slot
  id: variable_qtgui_entry
  parameters:
    comment: Nitrokey slot number (0-15) containing Ed25519 public key
    entry_signal: editingFinished
    gui_hint: 1,0,1,1
    label: Nitrokey Slot
    type: int
    value: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 448.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: Sample rate for audio processing
    value: '8000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [440, 24.0]
    rotation: 0
    state: enabled
- name: audio_sink_0
  id: audio_sink
  parameters:
    affinity: ''
    alias: ''
    comment: Audio output for verified voice
    device_name: ''
    num_inputs: '1'
    ok_to_block: 'True'
    samp_rate: '48000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1560, 216.0]
    rotation: 0
    state: enabled
- name: blocks_file_source_0
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.PMT_NIL
    comment: Load signed M17 signal from file
    file: /tmp/m17_signed.bin
    length: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'False'
    type: short
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 184.0]
    rotation: 0
    state: enabled
- name: blocks_short_to_float_0
  id: blocks_short_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: Convert short audio to float
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '32768'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1176, 216.0]
    rotation: 0
    state: enabled
- name: blocks_throttle2_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: short
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [216, 208.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport struct\ntry:\n\
      \    from gnuradio import nacl\n    NACL_AVAILABLE = True\nexcept ImportError:\n\
      \    NACL_AVAILABLE = False\n    print(\"Warning: gr-nacl not available. Verification\
      \ will not work.\")\n\ntry:\n    from python.m17_frame import M17Frame\n   \
      \ M17_AVAILABLE = True\nexcept ImportError:\n    try:\n        from m17_frame\
      \ import M17Frame\n        M17_AVAILABLE = True\n    except ImportError:\n \
      \       M17_AVAILABLE = False\n        print(\"Warning: M17 frame module not\
      \ available.\")\n\nclass blk(gr.sync_block):\n    def __init__(self):\n    \
      \    gr.sync_block.__init__(\n            self,\n            name='M17 Voice\
      \ Verifier',\n            in_sig=[np.uint8, np.uint8],\n            out_sig=[(np.uint8,\
      \ 48)]\n        )\n        self._m17_buffer = bytearray()\n        self._key_buffer\
      \ = bytearray()\n        self._signature_length = 64  # Ed25519 signature is\
      \ 64 bytes\n        self._m17_frame_size = 20  # M17 stream frame: sync (2)\
      \ + payload (16) + counter (2)\n        \n    def work(self, input_items, output_items):\n\
      \        m17_in = input_items[0]\n        key_in = input_items[1]\n        \n\
      \        # Collect M17 frame data\n        if len(m17_in) > 0:\n           \
      \ self._m17_buffer.extend(m17_in.tolist())\n        \n        # Collect key\
      \ data from Nitrokey (need 32 bytes for Ed25519)\n        if len(key_in) > 0:\n\
      \            self._key_buffer.extend(key_in.tolist())\n        \n        out_len\
      \ = min(len(output_items[0]), 48)\n        \n        # Verify when we have complete\
      \ M17 frame\n        if len(self._m17_buffer) >= self._m17_frame_size and len(self._key_buffer)\
      \ >= 32:\n            try:\n                # Extract M17 frame\n          \
      \      frame_bytes = bytes(self._m17_buffer[:self._m17_frame_size])\n      \
      \          self._m17_buffer = self._m17_buffer[self._m17_frame_size:]\n    \
      \            \n                # Parse M17 frame\n                if M17_AVAILABLE:\n\
      \                    m17_frame = M17Frame.from_bytes(frame_bytes)\n        \
      \            if m17_frame:\n                        payload = m17_frame.payload\n\
      \                    else:\n                        payload = frame_bytes[2:18]\
      \  # Skip sync word\n                else:\n                    # Simple parsing:\
      \ skip sync word (2 bytes), get payload (16 bytes)\n                    if len(frame_bytes)\
      \ >= 18:\n                        sync_word = struct.unpack('>H', frame_bytes[0:2])[0]\n\
      \                        if sync_word == 0xFF5D:  # M17 stream sync\n      \
      \                      payload = frame_bytes[2:18]\n                       \
      \ else:\n                            payload = frame_bytes[2:18]  # Try anyway\n\
      \                    else:\n                        payload = frame_bytes[2:]\
      \ if len(frame_bytes) > 2 else b''\n                \n                # Extract\
      \ Codec2 frame and signature from payload\n                # Payload contains:\
      \ codec2_frame (8) + signature (64) = 72 bytes\n                # But M17 payload\
      \ is only 16 bytes, so we need to handle this differently\n                #\
      \ For M17, we'll use the first 8 bytes as Codec2, and embed signature in metadata\n\
      \                # Or use multiple frames. For simplicity, assume signature\
      \ is in first 8 bytes + next 64\n                if len(payload) >= 8:\n   \
      \                 codec2_frame = payload[:8]\n                    # Signature\
      \ might be in next frame or appended\n                    # For this demo, assume\
      \ signature is in the payload if available\n                    if len(payload)\
      \ >= 72:\n                        signature = payload[8:72]\n              \
      \      else:\n                        # Try to get signature from next frame\
      \ or use placeholder\n                        signature = b'\\x00' * 64\n  \
      \              else:\n                    codec2_frame = payload\n         \
      \           signature = b'\\x00' * 64\n                 \n                #\
      \ Get public key (32 bytes for Ed25519)\n                public_key = bytes(self._key_buffer[:32])\n\
      \            \n                if NACL_AVAILABLE and len(public_key) == 32 and\
      \ len(signature) == 64:\n                    # Verify Ed25519 signature using\
      \ gr-nacl\n                    try:\n                        is_valid = nacl.verify_ed25519(codec2_frame,\
      \ signature, public_key)\n                        if is_valid:\n           \
      \                 # Output verified Codec2 frame\n                         \
      \   out_data = np.frombuffer(codec2_frame[:out_len], dtype=np.uint8)\n     \
      \                       if len(out_data) <= len(output_items[0]):\n        \
      \                        output_items[0][:len(out_data)] = out_data\n      \
      \                          return len(out_data)\n                        else:\n\
      \                            print(f\"FAILED: M17 Codec2 frame signature is\
      \ INVALID\")\n                            # Output silent frame on verification\
      \ failure\n                            silent_frame = b'\\x00' * 8\n       \
      \                     out_data = np.frombuffer(silent_frame[:out_len], dtype=np.uint8)\n\
      \                            if len(out_data) <= len(output_items[0]):\n   \
      \                             output_items[0][:len(out_data)] = out_data\n \
      \                               return len(out_data)\n                    except\
      \ AttributeError:\n                        print(\"Warning: gr-nacl verify_ed25519\
      \ not found. Cannot verify.\")\n                        # Pass through without\
      \ verification\n                        out_data = np.frombuffer(codec2_frame[:out_len],\
      \ dtype=np.uint8)\n                        if len(out_data) <= len(output_items[0]):\n\
      \                            output_items[0][:len(out_data)] = out_data\n  \
      \                          return len(out_data)\n                else:\n   \
      \                 print(\"Warning: Verification not available - missing key\
      \ or signature\")\n                    # Pass through without verification\n\
      \                    out_data = np.frombuffer(codec2_frame[:out_len], dtype=np.uint8)\n\
      \                    if len(out_data) <= len(output_items[0]):\n           \
      \             output_items[0][:len(out_data)] = out_data\n                 \
      \       return len(out_data)\n            except Exception as e:\n         \
      \       print(f\"Verification error: {e}\")\n                import traceback\n\
      \                traceback.print_exc()\n                # Output silent frame\
      \ on error\n                silent_frame = b'\\x00' * 8\n                out_data\
      \ = np.frombuffer(silent_frame[:out_len], dtype=np.uint8)\n                if\
      \ len(out_data) <= len(output_items[0]):\n                    output_items[0][:len(out_data)]\
      \ = out_data\n                    return len(out_data)\n        \n        #\
      \ No data to output yet\n        return 0\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('M17 Voice Verifier', 'blk', [], [('0', 'byte', 1), ('1', 'byte',
      1)], [('0', 'byte', 48)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 272.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \    def __init__(self):\n        gr.sync_block.__init__(\n            self,\n\
      \            name='M17 Demodulator',\n            in_sig=[np.short],\n     \
      \       out_sig=[np.uint8]\n        )\n        # M17 uses 4FSK demodulation\n\
      \        # For simplicity, this is a placeholder that passes through\n     \
      \   # In a real implementation, this would do M17 4FSK demodulation\n      \
      \  \n    def work(self, input_items, output_items):\n        in_data = input_items[0]\n\
      \        out_len = min(len(output_items[0]), len(in_data))\n        \n     \
      \   # Simple pass-through (actual M17 demodulation would go here)\n        #\
      \ M17 uses 4FSK: 4 frequencies map to symbols\n        # This is a placeholder\
      \ - real M17 demodulator would do:\n        # 1. Detect 4FSK frequencies\n \
      \       # 2. Map frequencies to symbols (2 bits per symbol)\n        # 3. Convert\
      \ symbols to bytes\n        \n        # For now, just convert short to bytes\n\
      \        out_data = (in_data.astype(np.int32) + 128).astype(np.uint8)\n    \
      \    if len(out_data) <= len(output_items[0]):\n            output_items[0][:len(out_data)]\
      \ = out_data\n            return len(out_data)\n        \n        return 0\n"
    affinity: ''
    alias: ''
    comment: M17 4FSK demodulator placeholder - converts audio samples to M17 frame
      bytes
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('M17 Demodulator', 'blk', [], [('0', 'short', 1)], [('0', 'byte',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [400, 192.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nfrom PyQt5.QtWidgets import (QDialog, QVBoxLayout, QLineEdit, QPushButton, QLabel, QMessageBox)\nfrom PyQt5.QtCore import Qt\nimport sys\n\ntry:\n    from libnitrokey import NitrokeyManager\n    NITROKEY_AVAILABLE = True\nexcept ImportError:\n    NITROKEY_AVAILABLE = False\n    print(\"Warning: libnitrokey Python bindings not available. PIN authentication will not work.\")\n\nclass PinEntryDialog(QDialog):\n    def __init__(self, parent=None, prompt=\"Enter Nitrokey PIN\"):\n        super().__init__(parent)\n        self.setWindowTitle(\"Nitrokey PIN Entry\")\n        self.setModal(True)\n        self.pin = None\n        self.cancelled = False\n        layout = QVBoxLayout()\n        label = QLabel(prompt)\n        layout.addWidget(label)\n        self.pin_input = QLineEdit(self)\n        self.pin_input.setEchoMode(QLineEdit.Password)\n        self.pin_input.returnPressed.connect(self.submit_pin)\n        layout.addWidget(self.pin_input)\n        button_layout = QVBoxLayout()\n        submit_button = QPushButton(\"Submit\")\n        submit_button.clicked.connect(self.submit_pin)\n        button_layout.addWidget(submit_button)\n        cancel_button = QPushButton(\"Cancel\")\n        cancel_button.clicked.connect(self.cancel)\n        button_layout.addWidget(cancel_button)\n        layout.addLayout(button_layout)\n        self.setLayout(layout)\n        self.pin_input.setFocus()\n    def submit_pin(self):\n        self.pin = self.pin_input.text()\n        if self.pin:\n            self.accept()\n        else:\n            QMessageBox.warning(self, \"Error\", \"PIN cannot be empty\")\n    def cancel(self):\n        self.cancelled = True\n        self.reject()\n    def get_pin(self):\n        return self.pin if not self.cancelled else None\n\nclass blk(gr.sync_block):\n    def __init__(self):\n        gr.sync_block.__init__(self, name='Nitrokey PIN Authenticator', in_sig=None, out_sig=None)\n        self.message_port_register_out(pmt.intern('status'))\n        self.authenticated = False\n        self.nitrokey_manager = None\n        self.last_button_state = False\n        self.check_counter = 0\n        self.button_var = None\n        if NITROKEY_AVAILABLE:\n            try:\n                self.nitrokey_manager = NitrokeyManager.instance()\n                if self.nitrokey_manager and self.nitrokey_manager.is_connected():\n                    print(\"Nitrokey PIN Authenticator: Device connected\")\n                else:\n                    print(\"Nitrokey PIN Authenticator: No device connected\")\n            except Exception as e:\n                print(f\"Nitrokey PIN Authenticator: Error connecting to device: {e}\")\n    def work(self, input_items, output_items):\n        self.check_counter += 1\n        if self.check_counter >= 100:\n            self.check_counter = 0\n            try:\n                if self.button_var is None:\n                    import __main__\n                    if hasattr(__main__, 'authenticate_button'):\n                        self.button_var = getattr(__main__, 'authenticate_button')\n                if self.button_var:\n                    button_value = self.button_var.value()\n                    if button_value and not self.last_button_state and not self.authenticated:\n                        self.authenticate_with_pin()\n                    elif not button_value:\n                        self.authenticated = False\n                    self.last_button_state = button_value\n            except Exception as e:\n                pass\n        return 0\n    def authenticate_with_pin(self):\n        if not NITROKEY_AVAILABLE or not self.nitrokey_manager:\n            status_msg = pmt.intern(\"Nitrokey library not available\")\n            self.message_port_pub(pmt.intern('status'), status_msg)\n            print(\"Nitrokey PIN Authenticator: Library not available\")\n            return\n        try:\n            if not self.nitrokey_manager.is_connected():\n                devices = self.nitrokey_manager.list_devices()\n                if not devices:\n                    status_msg = pmt.intern(\"No Nitrokey device found\")\n                    self.message_port_pub(pmt.intern('status'), status_msg)\n                    print(\"Nitrokey PIN Authenticator: No device found\")\n                    return\n                if not self.nitrokey_manager.connect():\n                    status_msg = pmt.intern(\"Failed to connect to Nitrokey\")\n                    self.message_port_pub(pmt.intern('status'), status_msg)\n                    print(\"Nitrokey PIN Authenticator: Connection failed\")\n                    return\n            from PyQt5.QtWidgets import QApplication\n            app = QApplication.instance()\n            parent = app.activeWindow() if app else None\n            dialog = PinEntryDialog(parent, \"Enter Nitrokey PIN for authentication\")\n            if dialog.exec_() == QDialog.Accepted:\n                pin = dialog.get_pin()\n                if pin:\n                    try:\n                        slot_status = self.nitrokey_manager.get_password_safe_slot_status()\n                        self.authenticated = True\n                        status_msg = pmt.intern(\"Authentication successful\")\n                        self.message_port_pub(pmt.intern('status'), status_msg)\n                        print(\"Nitrokey PIN Authenticator: Authentication successful\")\n                        pin = None\n                    except Exception as e:\n                        status_msg = pmt.intern(f\"Authentication failed: {str(e)}\")\n                        self.message_port_pub(pmt.intern('status'), status_msg)\n                        print(f\"Nitrokey PIN Authenticator: Authentication failed: {e}\")\n                        self.authenticated = False\n                else:\n                    status_msg = pmt.intern(\"PIN entry cancelled\")\n                    self.message_port_pub(pmt.intern('status'), status_msg)\n                    print(\"Nitrokey PIN Authenticator: PIN entry cancelled\")\n            else:\n                status_msg = pmt.intern(\"PIN dialog cancelled\")\n                self.message_port_pub(pmt.intern('status'), status_msg)\n                print(\"Nitrokey PIN Authenticator: Dialog cancelled\")\n        except Exception as e:\n            status_msg = pmt.intern(f\"Error: {str(e)}\")\n            self.message_port_pub(pmt.intern('status'), status_msg)\n            print(f\"Nitrokey PIN Authenticator: Error: {e}\")\n            import traceback\n            traceback.print_exc()\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Nitrokey PIN Authenticator', 'blk', [], [], [('status', 'message', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 552.0]
    rotation: 0
    state: enabled
- name: linux_crypto_nitrokey_interface_0
  id: linux_crypto_nitrokey_interface
  parameters:
    affinity: ''
    alias: ''
    auto_repeat: 'False'
    comment: Load Ed25519 public key from Nitrokey slot for verification
    maxoutbuf: '0'
    minoutbuf: '0'
    slot: nitrokey_slot
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [504, 352.0]
    rotation: 0
    state: enabled
- name: rational_resampler_xxx_1
  id: rational_resampler_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: Resample audio from 8kHz to 48kHz
    decim: '1'
    fbw: '0'
    interp: '6'
    maxoutbuf: '0'
    minoutbuf: '0'
    taps: ''
    type: fff
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1352, 192.0]
    rotation: 0
    state: enabled
- name: vocoder_codec2_decode_ps_0
  id: vocoder_codec2_decode_ps
  parameters:
    affinity: ''
    alias: ''
    comment: Codec2 decoder - decompresses verified voice bits
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: codec2.MODE_2400
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [968, 216.0]
    rotation: 0
    state: enabled

connections:
- [blocks_file_source_0, '0', blocks_throttle2_0, '0']
- [blocks_short_to_float_0, '0', rational_resampler_xxx_1, '0']
- [blocks_throttle2_0, '0', epy_block_1, '0']
- [epy_block_0, '0', vocoder_codec2_decode_ps_0, '0']
- [epy_block_1, '0', epy_block_0, '0']
- [linux_crypto_nitrokey_interface_0, '0', epy_block_0, '1']
- [rational_resampler_xxx_1, '0', audio_sink_0, '0']
- [vocoder_codec2_decode_ps_0, '0', blocks_short_to_float_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
